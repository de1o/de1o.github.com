---
layout: post
title: C language Summarize
---

{{page.title}}
==============

<p class="meta">15 Sep 2012 - Nanjing</p>

把最近看《Pointer on C》和《Expert C Programming》学到的总结一下。

1.	C语言的一个要点就是：「标识符在使用的时候的形式要和定义的形式一样」，当然这个约定是有几个例外的，但大多时候如此。比如以前对函数指针的定义方式不理解，会以为要硬背写法。其实知道了解读C语言标识符定义的方式（实际上和表达式求值的顺序是一样的），就自然知道为什么要这样写了。
	
		#include<stdio.h>
		int f(void)
		{
			printf("hello world");
			return 0;
		}
		typedef int (*func)(void);
		main()
		{
			func ff = &f;
			(*ff)();
		}

	上面的定义，按首先对func标识符解引用，说明func是一个指针，那么得到了func指向的内容，即`*func`之后做了执行操作--"()"，也就是说func指向的内容是一个函数。int 说明函数的返回值是一个整型。连起来也就是说func是一个指向参数表为空，返回整型的函数的指针。任何一个函数，只要满足参数和返回值的要求，都能够用func去引用。引用的时候可以用`(*ff)()`解引用的方式来调用。实际上，直接使用ff()也是可以的，因为编译器调用函数的时候，实际上用的是函数的地址，也就是说，在使用函数名调用函数的时候，编译器会做一个取地址的操作，直接用ff()来调用函数省略了这一步骤。

	同样，const也可以这样理解，`int const *ptr` 和 `const int *ptr`声明的都是一个指向整型常量的指针，因为解引用操作在前，解的并不是`const`类型的指针。而`int * const ptr` 就是一个指向整型的常量指针（解引用解的是一个常量。）。指针指向的内存位置不能变，而该指针指向的内容可以变化。

2.	作为变量的标识符，都有作用域的范围，分为
	*	代码块作用域
	*	文件作用域
	* 	原型作用域
	*	函数作用域

	标识符还有链接属性(linkage)，链接属性决定的是如何处理出现在不同文件中的同名标识符。链接属性分为`internal`, `external`, `none`三种，`internal`表示在同一文件中出现的都指同一个实体，`external`则表示无论出现在多少文件里，都指的是同一个实体。`static`和`extern`就是用来改变标识符的链接属性的。

	标识符的存储类型决定了变量何时创建，何时销毁，保存在哪等。保存位置有三种：静态内存，运行时堆栈和寄存器。`static`, `register`可以用来改变变量的存储位置。

3.	左值和右值：左值是可以出现在等号左边的东西。等号表示把等号右边计算好的值存到等号左边所标识的地址里，所以左值一定要是一个确定的可预测的位置。

4.	什么时候数组和指针是相等的
	*	表达式里的`数组名`（对应与声明里的数组名）被编译器当作指向数组第一个元素的指针对待。
	*	下标引用符总是等于指针加上一个偏移量。
	*	函数参数里的数组名被当作指向数组第一个元素的指针（实际上传入函数的也只是该指针，以至于函数内部是无法知道数组的大小的，需要另外传一个参数进去）。数组并不是传值调用的。当然，如果按`当指向第一个元素的指针`来理解的话，也算是传值调用吧。
	
	在其他时候，指针和数组是不相等的，比如说sizeof的时候。
	
	另外，当你使用数组名来访问数组的元素，是直接访问数组所在的地址，而通过指针来访问，则要先访问指针所在的地址，取得指针的内容（数组首元素所在的地址），再访问该地址。

5.	`const`指的是，你不能通过该标识符来改变该内存位置的内容，但你可以通过指向其他位置的指针的移动，来改变这块内存的内容。它并不是绝对意义上的不可改变。